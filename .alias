if [ -f ~/.workalias ]; then
	source ~/.workalias
fi

## general
alias l='ls'
alias lsa='ls -goah'
alias lsd='ls -d */'
alias lsb='ls ~/bin'
alias ls.='ls -a | grep "^\."'
alias c='clear'
alias v=$EDITOR
alias e=$EDITOR
alias mvim='mvim -v'
alias up='cd ..'
alias upp='cd ../..'
alias uppp='cd ../../..'
alias cdh='cd ~/'
alias cdg='cd ~/git'
alias cdd='cd ~/git/dot-files/'
alias cdv='cd ~/.vim'
alias h='history'
alias myhelp='cat ~/git/dot-files/shellReminders.txt'

alias ea='$EDITOR ~/.alias && source ~/.alias'

alias tcopy="tr -d '\n' | pbcopy"
alias grep="grep --color=always"
alias irc="irssi"

# bluetooth
alias bton="blueutil --power 1"
alias btoff="blueutil --power 0"

# make and change directory
function mcd () { mkdir -p $1; cd $1; }

# perform ls after cd
function cdl () { cd "$@" && ls; }

alias gitx='open -a GitX .'

## git alias
alias git-short-sha='git rev-parse --short HEAD'
alias git-current-branch='git rev-parse --abbrev-ref HEAD'
alias eg='git config -e'
alias egg='git config --global -e'
alias g='git '
alias gs='git status '
alias ga='git add '
alias gaa='git add .'
alias gap='git add -p'
alias gai='git add -i '
alias gb='git branch --all -vv'
alias gbc='git rev-parse --abbrev-ref HEAD '
alias gc='git commit -m '
alias gcam='git commit -a -m '
alias gca='git commit --amend'
alias gf='git fetch --prune'
# open all conflict files in editor
alias gfix='$EDITOR `git diff --name-only | uniq`'
alias gd='git diff'
alias gds='git diff --staged'
# alias gdc='git diff --word-diff-regex=.'
alias gdc='git diff --cached'
alias go='git checkout '
alias gom='git checkout master '
alias god='git checkout develop '
alias gob='git checkout -B '
alias gp='git pull '
alias gpu='git push'
# push to remote and set upstream at the same time https://stackoverflow.com/a/6089415/640338
alias gpusu='git push -u origin HEAD'
alias gpu1='git push origin HEAD^:$(git rev-parse --abbrev-ref HEAD)'
alias gpu2='git push origin HEAD^^:$(git rev-parse --abbrev-ref HEAD)'
alias gm='git merge '
alias gmm='git merge origin master '
alias gms='git merge --squash '
alias gl='git log'
alias gcp='git cherry-pick '
alias gcpc='git cherry-pick --continue'
alias gcpa='git cherry-pick --abort'
# alias grb1='git reset --soft HEAD^'
# alias grb2='git reset HEAD .'
# git rebase split
alias grbs='git reset HEAD^'
# safe git reset hard avoiding commit hooks
alias grh='git add -A && git commit -qm "WIPE SAVEPOINT" --no-verify && git reset HEAD~1 --hard'
alias gwipe='git add -A && git commit -qm "WIPE SAVEPOINT" && git reset HEAD~1 --hard'
alias gmt='git mergetool '
alias gg='git grep '

# git rebase
alias grb='git rebase -i'
alias grbsh10='grbsh HEAD~10'
alias grbh='git rebase -i $H'
alias grbd='git rebase -i develop'
alias grbc='git rebase --continue'
alias grba='git rebase --abort'
# set $H to common ancestor or HEAD and develop
alias grbshb='grbsh `git merge-base develop HEAD`'
# set $H (hash) for grbh
function grbsh { export H="$1"; }

# git stash
alias gst='git stash --include-untracked'
alias gstl='git --no-pager stash list --pretty=format:"%C(red)%h%C(reset) - %C(dim yellow)(%C(bold magenta)%gd%C(dim yellow))%C(reset) %<(70,trunc)%s %C(green)(%cr) %C(bold blue)<%an>%C(reset)" && echo'
alias gstn='git stash save'
alias gstnp='git stash save -p'
alias gstp='git stash pop'
alias gsta='git-stash-apply'
alias gsta0='git stash apply stash@{0}'
alias gstd='git-stash-drop '
alias gstd0='git stash drop stash@{0}'
alias gsts='git-stash-show '
function git-stash-apply () { git stash apply stash@{"$1"}; }
function git-stash-drop () { git stash drop stash@{"$1"}; }
function git-stash-show () { git show stash@{"$1"}; }

alias myip='ifconfig en0'
alias pi='pod install'
alias pu='pod repo update'
alias unquarantine='xattr -d com.apple.quarantine'

# wifi on/off
alias wifi="networksetup -setairportpower en0"
alias wifiToggle="wifi off && sleep 10 && wifi on"

# kill Xcode and nuke derived data
alias nukederiveddata='rm -rf $HOME/Library/Developer/Xcode/DerivedData'
alias killxcode='killall - Xcode && nukederiveddata'
alias killsimulator='sudo killall -9 com.apple.CoreSimulator.CoreSimulatorService'

alias beep="echo -ne '\007'"

# for repeating the last command
# see http://stackoverflow.com/questions/4956018/in-git-how-can-i-stage-a-file-i-have-just-diffed-without-manually-specifying-the/4956417#4956417
# $ cc
# $ r sudo # would execute r cc
alias r='fc -s'

# read -p "Are you sure? " -n 1 -r
# echo    # (optional) move to a new line
# if [[ $REPLY =~ ^[Yy]$ ]]
# then
#   # do dangerous stuff
# fi

# alias tail_ls="ls -l $1 | tail"

function gdelbn () {
	if [ $# -eq 0 ]
	then
		echo "No arguments supplied"
		return
	fi
	branchToDelete=$(git branch | sed -n "$1"p)
	read -p "Will delete branch $branchToDelete. Proceed? (Enter) - (^C to abort)"
	git branch -D $branchToDelete;
}

# from `git branch` check out branch N
function git-checkout-branch-n () {
	git checkout `git branch | sed -n "$1"p`;
}

# Show the Nth commit in the project
function hockeyNumberToHash() {
	re='^[0-9]+$'
	if ! [[ $1 =~ $re ]] ; then
		echo "error: Not a number" >&2; return
	fi
	totalCommits=$(git rev-list HEAD --count)
	reverseCommit=$(expr $totalCommits - "$1") # the following command skips from HEAD backwards so we need to find the number of commits from HEAD
	echo Total commits: $totalCommits, Commits behind HEAD: $reverseCommit
	git log --skip=$reverseCommit --max-count=1
}

function hockeyHashToNumber() {
	if test $(git cat-file -t $1) == commit; then
		totalCommits=$(git rev-list HEAD --count)
		thisCommit=$(git rev-list "$1" --count)
		reverseCommit=$(expr $totalCommits - $thisCommit) # the following command skips from HEAD backwards so we need to find the number of commits from HEAD
		echo Total commits: $totalCommits, Commit behind HEAD: $reverseCommit, Commit number: $thisCommit
	else
		echo "error: Input not a commit" >&2; return
	fi
}

# get current branch "TICKET-123/aBranchDescription" and return "TICKET-123"
alias ticket-number-of-current-branch='git-current-branch | sed -e "s/\/.*$//g"'
alias openticket-of-current-branch='open $JIRA_INSTANCE_URL`ticket-number-of-current-branch`'

# http://unix.stackexchange.com/questions/97920/how-to-cd-automatically-after-git-clone
# if cloning, cd into directory after clone is completed
# git()
# {
#    local tmp=$(mktemp)
#    local repo_name
#
#    if [ "$1" = clone ] ; then
#      /usr/bin/git "$@" | tee $tmp
#      repo_name=$(awk -F\' '/Cloning into/ {print $2}' $tmp)
#      rm $tmp
#      printf "changing to directory %s\n" "$repo_name"
#      cd "$repo_name"
#    else
#      /usr/bin/git "$@"
#    fi
# }

#function lazyclone {
#    url=$1;
#    reponame=$(echo $url | awk -F/ '{print $NF}' | sed -e 's/.git$//');
#    git clone $url $reponame;
#    cd $reponame;
#}

#### Get os name via uname ###
#_myos="$(uname)"

#### add alias as per os using $_myos ###
#case $_myos in
#   Linux) alias foo='/path/to/linux/bin/foo';;
#   FreeBSD|OpenBSD) alias foo='/path/to/bsd/bin/foo' ;;
#   SunOS) alias foo='/path/to/sunos/bin/foo' ;;
#   Darwin) alias foo='' ;;
#   *) ;;
#esac

# vim: filetype=sh
